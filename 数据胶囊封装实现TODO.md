# 数据胶囊封装实现 TODO 清单

## 项目概述
基于白皮书设计思想，capsula-core需要实现完整的0/1/2阶数据胶囊封装系统。目前项目已有基础的SealedBlock实现，需要在此基础上构建完整的分层胶囊架构。

## 当前实现状态分析

### ✅ 已完成的基础组件
- **SealedBlock**: 最小可验证封装单元（`block/mod.rs`）
  - 支持AEAD加密（AES-256-GCM）
  - 密钥环管理（KeyWrap）
  - 作者证明（AuthorProof）
  - 内联和外部存储支持
- **基础数据结构**: Header, Integrity, Digest, Signature等
- **密钥系统**: 基于RSA的密钥封装和解封

### ❌ 缺失的核心组件
- **胶囊状态管理**：Pending/Uploading/Completed状态系统
- **异步封装机制**：非阻塞的封装和上传流程
- **0/1/2阶胶囊结构**：Cap0、Cap1、Cap2类型定义
- **通用胶囊外壳**：统一的Capsule容器
- **AAD绑定机制**：防篡改的额外认证数据
- **分层封装API**：便于使用的高级接口
- **权限控制系统**：基于指针的访问控制
- ~~**ZKP证明支持**：零知识证明集成框架~~ **暂不实现**

## 关键架构决策：封装与存储分离

### 🎯 设计原则：状态管理的异步封装

**核心思路**：
- 数据胶囊具有状态，标识封装完成度
- 封装立即完成但处于Pending状态
- 上传异步进行，状态动态更新
- 支持批量操作和进度监控

**状态驱动的异步工作流**：
```rust
// 1. 立即创建Pending状态的胶囊（同步）
let pending_capsule = SealedBlock::seal_pending(
    plaintext,
    content_type,
    aad,
    keyring,
    recipient_key,
    signing_key,
)?;

// 2. 异步上传，状态自动更新
let upload_task = pending_capsule.start_upload(storage_backend).await?;

// 3. 监控进度或等待完成
match upload_task.get_state() {
    CapsuleState::Uploading { progress, .. } => println!("进度: {}%", progress * 100.0),
    CapsuleState::Completed { final_uri, .. } => println!("完成: {}", final_uri),
    CapsuleState::Failed { error, .. } => println!("失败: {}", error),
    _ => {}
}
```

**优点**：
- 真正的异步：封装不被上传阻塞
- 状态可追踪：清楚了解每个胶囊状态
- 批量友好：可创建多个Pending胶囊后批量上传
- 错误恢复：失败的胶囊可以重试
- 进度监控：支持上传进度回调

## 详细实现计划

### 阶段0：状态管理和异步封装 (最高优先级)

#### 0.1 胶囊状态系统
- [ ] **创建 `src/state/mod.rs`**
  - 定义 `CapsuleState` 枚举
  - 实现状态转换逻辑
  - 添加状态验证和序列化

#### 0.2 异步封装API
- [ ] **扩展 `src/block/mod.rs`**
  - 添加 `state: CapsuleState` 字段到 `SealedBlock`
  - 实现 `seal_pending` 方法（创建Pending状态胶囊）
  - 实现状态转换方法（`start_upload`, `mark_completed`等）
  - 保持现有同步封装API兼容

#### 0.3 上传任务管理
- [ ] **创建 `src/upload/mod.rs`**
  - 定义 `UploadTask` 结构体
  - 实现上传进度跟踪
  - 支持任务取消和重试
  - 提供批量上传接口

### 阶段1：核心数据结构定义 (高优先级)

#### 1.1 定义0阶数据胶囊 (Cap0)
- [ ] **创建 `src/capsule/cap0.rs`**
  - 定义 `Cap0` 结构体
  - 包含 `origin: SealedBlock` (原始数据)
  - 可选 `origin_text: Option<SealedBlock>` (文字注释版)
  - 实现序列化/反序列化

#### 1.2 定义1阶数据胶囊 (Cap1)
- [ ] **创建 `src/capsule/cap1.rs`**
  - 定义 `Cap1` 结构体
  - 包含 `cap0_id: String` (关联0阶胶囊)
  - 包含 `meta: SealedBlock` (元数据密文)
  - 包含 `summary: SealedBlock` (摘要密文)
  - ~~预留 `zkp: Option<ZkpProof>` (零知识证明)~~ **暂不实现**

#### 1.3 定义2阶数据胶囊 (Cap2)
- [ ] **创建 `src/capsule/cap2.rs`**
  - 定义 `Cap2` 结构体
  - 包含 `owner_id: String` (所有者标识)
  - 包含 `refs: Vec<RefEntry>` (引用条目)
  - 包含 `bundle_hash: Digest` (捆绑哈希)
  - 包含 `bundle_signature: Signature` (捆绑签名)
  - 定义 `RefEntry` 结构体

#### 1.4 重构通用胶囊外壳
- [ ] **修改 `src/capsule/mod.rs`**
  - 重新设计 `Capsula` 结构体为统一外壳
  - 添加 `aad: String` 字段（额外认证数据）
  - 修改 `payload` 字段支持 `Cap0 | Cap1 | Cap2`
  - 更新 `policy` 为指针引用模式
  - 确保与现有代码兼容

### 阶段2：AAD绑定和安全机制 (高优先级)

#### 2.1 实现AAD计算和绑定
- [ ] **创建 `src/security/aad.rs`**
  - 实现AAD计算函数（header + policy + keyring + payload摘要）
  - 提供标准化序列化方法
  - 支持不同胶囊类型的AAD计算

#### 2.2 增强完整性验证
- [ ] **扩展 `src/integrity/mod.rs`**
  - 添加整体胶囊签名验证
  - 实现Merkle根计算（为复杂结构）
  - 添加篡改检测机制

#### 2.3 权限控制系统基础
- [ ] **创建 `src/policy/control.rs`**
  - 定义 `Control` 结构体（acl_ref指针模式）
  - 实现权限引用和验证框架
  - 为后续权限系统预留接口

### 阶段3：封装和解封API (中优先级)

#### 3.1 0阶胶囊封装器
- [ ] **创建 `src/encapsulator/cap0_builder.rs`**
  - 实现原始数据 → Cap0的封装流程
  - 支持文件和文字注释的双重封装
  - 提供便捷的Builder模式API
  - 集成S3外部存储支持

#### 3.2 1阶胶囊封装器
- [ ] **创建 `src/encapsulator/cap1_builder.rs`**
  - 实现元数据和摘要的封装
  - 提供0阶胶囊关联机制
  - 支持BNF到JSON的结构化转换
  - 预留ZKP证明集成点

#### 3.3 2阶胶囊封装器
- [ ] **创建 `src/encapsulator/cap2_builder.rs`**
  - 实现按所有者聚合的封装逻辑
  - 提供类型化引用管理
  - 实现bundle哈希和签名

#### 3.4 统一封装API
- [ ] **创建 `src/encapsulator/unified.rs`**
  - 提供高级封装API
  - 支持一步式多阶胶囊创建
  - 实现封装链的自动管理

### 阶段4：解封和验证API (中优先级)

#### 4.1 分层解封器
- [ ] **创建 `src/decapsulator/`目录**
  - `cap0_decoder.rs`: 0阶胶囊解封
  - `cap1_decoder.rs`: 1阶胶囊解封 
  - `cap2_decoder.rs`: 2阶胶囊解封
  - `unified.rs`: 统一解封API

#### 4.2 验证框架
- [ ] **创建 `src/validator/`目录**
  - 实现分层验证逻辑
  - 签名链验证
  - 完整性校验
  - 权限检查框架

### 阶段5：外部集成和扩展 (低优先级)

#### 5.1 真实存储后端实现 
- [ ] **实现 `src/storage/`模块**
  - 完成S3存储后端实现
  - 集成到上传任务管理器
  - 支持大文件的流式处理
  - 添加存储完整性验证
  - 实现断点续传功能

#### 5.2 高级状态管理
- [ ] **扩展状态系统**
  - 实现状态持久化（数据库/文件）
  - 添加状态变化事件通知
  - 支持分布式状态同步
  - 实现状态统计和监控

#### 5.3 ZKP证明框架 **🚫 暂不实现**
- [ ] ~~**创建 `src/zkp/`模块**~~
  - ~~定义ZKP证明结构~~
  - ~~提供电路集成接口~~
  - ~~实现文本片段证明~~
- **说明**：ZKP证明系统复杂度高，需要专门的密码学专家设计。当前阶段专注于核心的数据胶囊封装功能，ZKP证明留待后续版本实现。

#### 5.4 审计日志系统
- [ ] **创建 `src/audit/`增强**
  - 实现操作审计记录
  - 提供可追溯性支持
  - 集成外部审计系统
  - 记录状态变化历史

### 阶段6：API和工具类 (低优先级)

#### 6.1 便捷API
- [ ] **创建 `src/api/`模块**
  - 提供医疗场景的专用API
  - 实现常用封装模式
  - 添加批量处理支持

#### 6.2 CLI工具支持
- [ ] **扩展示例和工具**
  - 添加命令行封装工具
  - 提供调试和验证工具
  - 创建测试数据生成器

### 阶段7：测试和文档 (持续)

#### 7.1 单元测试
- [ ] **为每个模块添加测试**
  - 封装/解封Round-trip测试
  - 错误情况测试
  - 性能基准测试

#### 7.2 集成测试
- [ ] **端到端测试场景**
  - 完整的医疗数据处理流程
  - 多用户协作场景
  - 权限控制验证

#### 7.3 文档和示例
- [ ] **API文档和使用指南**
  - Rust文档注释完善
  - 使用示例和教程
  - 最佳实践指南

## 实现优先级和时间规划

### 第一周：状态管理和核心结构
- 阶段0：状态管理和异步封装机制
- 阶段1：数据结构定义 (Cap0/1/2)
- 阶段2：AAD绑定和安全机制

### 第二周：封装功能  
- 阶段3：分层封装API实现
- 基础测试（使用Pending状态胶囊）

### 第三周：解封功能
- 阶段4：解封和验证API
- 集成测试

### 第四周：文档和优化
- 阶段6：API优化和便捷接口
- 阶段7：文档完善

### 后续版本：存储集成和高级功能
- 阶段5：真实S3存储后端实现
- 高级状态管理（持久化、监控）
- 断点续传和批量上传优化

## 关键技术决策

1. **状态驱动设计**: 胶囊具有明确状态，支持异步工作流
2. **真正的异步**: 封装立即完成，上传独立进行，互不阻塞
3. **批量友好**: 支持创建多个Pending胶囊后批量处理
4. **向后兼容**: 确保新的状态系统与现有SealedBlock兼容
5. **安全优先**: AAD绑定防止组件替换攻击
6. **可扩展性**: 为多种存储后端和状态管理模式预留接口
7. **易用性**: 提供Builder模式和高级API，隐藏状态复杂性
8. **可监控性**: 状态可追踪，支持进度监控和错误恢复

## 风险和缓解策略

- **状态一致性风险**: 并发状态变更可能导致数据不一致
  - *缓解*: 使用原子操作，实现状态锁机制，添加状态验证
- **异步复杂性风险**: 异步流程增加调试和错误处理难度
  - *缓解*: 完善的日志记录，状态变化审计，提供同步包装器
- **内存泄漏风险**: Pending状态的胶囊可能积累过多未完成任务
  - *缓解*: 实现超时清理机制，内存使用监控，任务队列限制
- **向后兼容风险**: 状态系统可能破坏现有代码
  - *缓解*: 保持API版本化，提供迁移路径，渐进式重构
- **安全风险**: 状态信息可能泄露敏感数据
  - *缓解*: 状态信息最小化，敏感数据加密存储，访问控制
- **性能风险**: 状态管理开销可能影响性能
  - *缓解*: 性能基准测试，状态缓存优化，批量操作支持

---

*本TODO清单基于当前代码分析和白皮书设计要求制定，将根据实施进展动态调整*