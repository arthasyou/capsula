# 说明
以下内容是基于白皮书理念的推演性设计，原文未包含这些实现细节，目的是为开发提供指导方案。

# 数据胶囊技术白皮书 v1.2

《数据胶囊技术白皮书 v1.2》里面明确写到，数据胶囊的安全目标就是保证在存储、传输和使用过程中实现这五个方面：

- 机密性 (Confidentiality)：数据加密保护，避免未授权泄露。
- 完整性 (Integrity)：数字签名、水印，确保数据未被篡改。
- 可用性 (Availability)：数据在需要时可被合法使用。
- 可控性 (Controllability)：访问控制和授权策略，使用者必须符合规则。
- 可追溯性 (Traceability)：操作日志和审计记录，可溯源、合规。

这篇文章明确说明了上面5点概念，但是没有说明 零知识证明（zkp）如何使用

## 原始数据

在数据胶囊的定义里，原始数据本身是不限定格式的，它可以是：

- 结构化数据：表格、JSON、CSV（如血检指标）。
- 非结构化数据：
  - 文本（病历记录、诊断意见）
  - 图片（CT、MRI、X光片、病理切片）
  - 视频（手术录像）
  - 音频（心电图声音信号、语音记录）
  - 其它二进制文件（PDF 报告、DICOM 医学影像格式）

换句话说：任何文件类型（不同后缀）都可以作为胶囊的数据本体。

## 0 阶级数据胶囊

- 原始数据处理：所有原始数据（不论格式）一律当作二进制文件，加密后存储到 S3。
- 最小索引结构：为了定位与管理，需要额外保存一个轻量级数据结构，称为 胶囊原始数据索引（也可理解为 0 阶数据胶囊）明文表示。

```json
{
  "capsule_id": "唯一标识符",
  "s3_uri": "s3://bucket/key",
  "file_type": "image/png"
}
```

## 2 零知识证明（zkp）

在数据胶囊的语境里，原始数据始终保持加密状态（只能由数据拥有者自己解封），其它人是看不到的。

但是，为了让别人“信任”某些结论或片段，就引入 ZKP：

- 原始数据：完整的体检报告 / 医学影像 → 永远加密保存，不直接泄露。
- ZKP 证明：我从原始数据里提取出“血糖值 > 7 mmol/L”这个事实，并生成一个数学证明，让别人相信它确实是真的。
- 对方获得：这个证明 + “血糖异常”的结论，而不需要看到完整的血检报告。

数据胶囊用 ZKP 的逻辑就是：

1. 不泄露原文 → 原始文件加密保存。
2. 只暴露需要的片段或结论 → 比如“指标异常/正常”。
3. 保证可信 → 用 ZKP 数学证明告诉对方，这个片段确实来自原始数据，而不是你编造的。

这样一来，数据就同时满足：

- 机密性（原始数据从不暴露）
- 可用性（对方得到需要的结论）
- 可追溯性（证明结论和原始数据绑定）

### ZKP 能做的

- ✅ 如果原始数据是文字/结构化文本（JSON、CSV、报告等），可以对其中的某个片段或字段生成 ZKP，证明它确实来自这份原始数据（比如“血糖值 > 7 mmol/L”）。

### ZKP 不能直接做的

- ❌ 如果原始数据是图片/视频/音频，ZKP 没办法直接证明“片段信息属于这个文件”。
- 因为图片里的文字、指标等，需要先经过 OCR/特征提取 变成可验证的文本或数值，ZKP 才能作用在这些“数字化后的内容”上。
- 对纯二进制图片文件，ZKP 只能证明“某个哈希对应这个图片”，不能证明“图片里写着贫血”。

## 数据胶囊的使用原则

- 原始文件（图片、视频、音频等）在封装时必须经过文字化转化（OCR、结构化解析、摘要提取）。
- 胶囊在对外提供可验证信息时，基本上只暴露文字信息片段，并通过 ZKP 来证明这些片段确实来源于原始文件。

这样就保证了：

- 原始文件始终加密保存；
- 对外共享的都是经过转化的文字片段；
- 文字片段的真实性通过 ZKP 来保证。

所以0阶数据胶囊还需要另外一个部分，就是存文字注释版的原始数据，这个数据也需要加密后存到s3服务器上。

原来的json结构就变成下面这样，需要加入sha256哈希值来保证原始数据的完整性质：

```json
{
  "capsule_id": "唯一标识符",
  "s3_uri": "s3://bucket/key",            // 原始文件密文
  "file_type": "image/png",
  "hash_raw": "sha256:abcdef1234...",      // 原始文件哈希
  "text_uri": "s3://bucket/text",          // 文字注释版密文
  "hash_text": "sha256:9876fedcba..."      // 文字注释版哈希
}
```

0阶数据胶囊不仅要有存储定位和哈希，还要有生产者的签名、证书、身份信息，这样才能：

- 证明原始数据确实来自可信生产者；
- 证明文字注释版确实由生产者生成（或确认过），保证二者的关联性；
- 提供后续追溯和不可抵赖性。

整理后的 0阶数据胶囊索引 可以这样写：

```json
{
  "capsule_0_id": "唯一标识符",
  "producer_id": "生产者唯一标识",      
  "producer_info": {
    "name": "医院A",
    "department": "检验科"
  },
  "s3_uri": "s3://bucket/key",             // 原始文件密文
  "file_type": "image/png",
  "hash_raw": "sha256:abcdef1234...",       // 原始文件哈希
  "text_uri": "s3://bucket/text",           // 文字注释版密文
  "hash_text": "sha256:9876fedcba...",      // 文字注释版哈希
  "signer_cert": "-----BEGIN CERTIFICATE-----...-----END CERTIFICATE-----",
  "signature": "base64签名值"
}
```

- signature = 生产者用私钥对 hash_raw + hash_text 做的签名；
- signer_cert = 生产者的公钥证书；
- producer_id / producer_info = 明确来源。

### producer_id / producer_info 是否需要保密

如果需要可以把这些信息放到一阶数据胶囊里面。

这样就能保证：

原始文件 ↔ 文字摘要 ↔ 生产者三者之间强绑定。


# 元数据
《白皮书》已经定义好了
元数据可包括各个一阶数据胶囊的6元素向量：

1. 数据采集者  
2. 数据拥有者  
3. 数据使用者  
4. 授权向量  
5. 数据摘要  
6. 使用期限  

考虑到元数据要以密文形式存储，需要把 3,4,5,6 从元数据脱离出来。

数据使用者是动态的，没有办法估计给谁使用。

数据摘要可以使用 bnf 来提取出字段保存成 json 格式。  
最终数据摘要也需要以密文的方式存储。  
一个秘密里面包含另一个密文再做一次加密不推荐，效率非常低，需要解密两次。

使用授权向量  
这个属于数据权属管理部分，是否可以考虑用明文。

使用期限  
这个应该不需要加密，可以以明文显示。

# 1 阶级数据胶囊的定义（实际使用的数据胶囊）。

最基础的结构不包含其它而外信息
下面数据结构只是一个示例（设计请参考数据胶囊结构）

```json
{
  "capsule_1_id": "唯一标识符",
  "capsule_0_id": "关联0阶数据胶囊",
  "metadata_enc": "base64...",
  "summary_enc": "base64...",
  "policy": "使用授权向量（明文）",
  "expires_at": "2026-12-31T23:59:59Z",
  "hash_summary": "摘要哈希值",
  "policy_signature": "授权向量签名"
}
```

- `hash_summary` 用于校验数据摘要的完整性，确保摘要在传输和存储过程中未被篡改。  
- `policy_signature` 用于保证授权向量的不可篡改性，确保使用授权信息的真实性和有效性。

这个 json 结构只是一个示意图，实际实现要比这个更复杂，具体实现请参考数据胶囊的封装与解封。  
数据摘要需要和 zkp 结合，这里也没有给出具体实现请参考zkp部分。

以上描述涉及到数据胶囊的3个部分
机密性 完整性 可用性 
还有2个 可控性 和 可追溯性没有接受

可控性《白皮书》里面已经说明使用授权向量，这个已经封装在数据胶囊里面了(但是这个设计是否合理)如果权限存储的是一个指针，把权限移步到外层独立设计是否更好呢？
可追溯性，属于审计部分，我觉得需要独立与数据胶囊之外来存储。因为是一个动态数据不方便封装在数据胶囊里面



# 2 阶数据胶囊

按照白皮书的思想

二阶数据胶囊是对一阶数据胶囊的再封装，但并不存储一阶胶囊的全部信息，而是通过引用一阶胶囊的 ID 来实现关联。直接将一阶胶囊完整封装到二阶胶囊中会导致数据量过大且存在大量冗余。

二阶数据胶囊维护一个按数据类型分类的映射（map），映射的值是对应一阶胶囊的 ID。二阶胶囊主要按照所有者进行分类，将同一所有者的不同胶囊聚合在一起，从而实现更高效的管理和访问。

```json
{
  "capsule_2_id": "唯一标识符",
  "owner_id": "所有者ID",
  "owner_info": { "name": "可选" },

 "refs": [
  { "type": "血常规报告", "ids": ["caps_id_1", "caps_id_2"] },
  { "type": "体检报告", "ids": ["caps_id_3"] }
]

  "created_at": "2025-09-19T08:00:00Z",
  "bundle_hash": "sha256:...",         // 对 refs 展平后的有序列表做哈希
  "bundle_signature": "base64..."      // 对 bundle_hash 的签名（可选）
}
```

关于refs里面的设计还需要优化目前只提供最简单的方案，字段可能还需要增加


## 本文件只聚焦五大目标（CIACT）的实现思路，不涉及管理系统设计

```
[数据生产端]
  ├─ 原始文件(图片/视频/文本/…)
  │      └─ 本地加密 → raw.enc  ─┐
  └─ 文字化( OCR/解析 ) → text.json
         └─ 本地加密 → text.enc ──┼──▶  [S3 对象存储]
                                   │       ├─ /raw/<hash>.enc      (原始文件密文)
                                   │       └─ /text/<hash>.enc     (文字描述密文)
                                   │
                                   │
                           ┌─────────────────────────────┐
                           │         0 阶数据胶囊         │
                           │  - s3_uri_raw,  hash_raw     │→ 指向 S3/raw
                           │  - s3_uri_text, hash_text    │→ 指向 S3/text
                           │  - signer_cert, signature    │(生产者签名/证书)
                           └───────────▲─────────────────┘
                                       │ capsule_0_id
                           ┌───────────┴─────────────────┐
                           │         1 阶数据胶囊         │
                           │  - capsule_0_id (关联 0 阶)   │
                           │  - metadata_enc              │(元数据密文, 内嵌)
                           │  - summary_enc + hash_summary│(BNF→JSON 摘要密文)
                           │  - policy_ref + policy_hash  │(授权指针+绑定哈希)
                           │  - expires_at                │(明文期限)
                           └───────────▲─────────────────┘
                                       │ 引用多个 1 阶
                           ┌───────────┴─────────────────┐
                           │         2 阶数据胶囊         │
                           │  - owner_id                  │(按所有者聚合)
                           │  - refs: [ {type, ids[]} ]   │(类型→一阶ID列表)
                           │  - bundle_hash/signature(*)  │(可选, 绑定引用集)
                           └─────────────────────────────┘

[审计/可追溯性]：独立日志系统（外部），胶囊内仅保留 audit_ref(可选)
[可控性/策略]：外部策略文档(OPA/证书扩展等)，由 policy_ref 引用
```









