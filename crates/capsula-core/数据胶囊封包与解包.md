# 设计思路

在数据胶囊的设计中，数据本体应该保持固定，而权限和授权信息需要独立出来。这样可以保证数据胶囊作为一个标准化的技术，在不同场景和行业里都能通用，不受具体使用者和权限变化的影响。

核心思路
	1.	数据一次封装
	•	生产者把数据内容分层（如标识层、概要层、完整层），每层用一个独立的 AES 密钥加密。
	•	所有 AES 密钥只需要加密给 Owner，存放在数据胶囊里。
	•	这样数据胶囊本体就是固定的，不随使用者变化而变化。
	2.	权限分离
	•	使用者不会直接出现在数据胶囊里。
	•	授权通过单独的 授权包（GrantEnvelope） 来实现，描述“哪个用户/组能解哪一层数据”。
	•	授权包里包含被授权层的 AES 密钥，这些密钥由 Owner 用接收者的公钥加密。
	3.	按需授权
	•	当某个用户需要访问时，Owner 用自己的私钥解开层的 AES 密钥，再用用户的公钥加密，生成授权包。
	•	授权包和数据胶囊一起发送给使用者。
	•	用户凭自己的私钥解出 AES 密钥，就能解密对应层的数据。
	4.	分组机制
	•	类似 Linux 文件权限模型，可以设置组（如护士组、医生组、主管医生组）。
	•	授权时，Owner 只需要给组分发密钥，组内成员自动继承访问权。
	•	这样权限管理更简单，也方便扩展。
	5.	动态管理
	•	新用户加入，只需要再发一份授权包，不用修改数据胶囊。
	•	撤销用户权限，只需要让对应的授权包失效，不影响已有数据。
	•	数据胶囊保持不变，生命周期更长，更稳定。

⸻

总结
	•	数据胶囊本体：一次封包，不依赖具体用户。
	•	权限与授权：独立管理，通过外部授权包控制。
	•	优点：跨行业通用、灵活授权、方便撤销、易于审计。

## 数据胶囊：封包与解包

## 介绍

1. 封包（Encapsulation）

目的：将原始数据（0 阶）转化为可安全流通的胶囊（1 阶或 2 阶）。
核心操作：
	1.	格式化：对原始数据进行统一的结构化表示（例如医疗报告 EBNF）。
	2.	摘要化：计算数据摘要（Digest），作为完整性与后续验证的基准。
	3.	加密：使用对称加密保护数据内容，仅保留少量可公开的元信息。
	4.	密钥分发：将加密所用的会话密钥，用接收方公钥加密后随胶囊一起分发。
	5.	完整性保护：对头部、元数据、载荷摘要进行数字签名，确保不可篡改。
	6.	策略绑定：可选地附加访问控制策略，定义谁、在什么条件下可解包。
	7.	审计起点：生成“创建”事件记录，保证可追溯性。

⸻

2. 解包（Decapsulation）

目的：在合法条件下还原原始数据，同时验证其安全属性。
核心操作：
	1.	结构校验：检查胶囊是否符合 EBNF 定义与版本规范。
	2.	策略检查：验证访问请求是否满足策略约束（证书、规则、Rego 等）。
	3.	签名验证：确认胶囊内容未被篡改，且确实来自声明的生产者。
	4.	密钥解析：从 Keyring 中找到自己的密钥，解开会话密钥。
	5.	数据解密：使用会话密钥解密载荷，得到原始明文数据。
	6.	摘要对比：重新计算数据摘要，与封包时保存的值比对，验证一致性。
	7.	审计记录：生成“读取 / 解密”事件，保证使用行为可追踪。

⸻

3. 学术要点总结
	•	封包：解决数据在流通过程中的 机密性、完整性 和 访问控制。
	•	解包：保证数据在授权主体手中被 正确还原，并通过 可验证的链条（摘要 + 签名 + 审计）维持信任。
	•	核心思想：
	•	通过 形式化语法（EBNF）定义结构 → 提供可验证的规范性；
	•	通过 密码学机制（摘要、加密、签名） → 提供安全性与不可抵赖性；
	•	通过 策略与审计 → 提供合规性与可追溯性。

4. 

## 1阶数据胶囊

### 封包

1. 格式化原始报告:
我们已经用 EBNF 定义了数据胶囊和医疗报告的形式化语法
在封包时，第一步就是用这个语法去解析原始报告，把它转化为一个符合 EBNF 的结构化对象
这个结构化对象在工程实现里可以是 JSON，也可以是某个程序语言对应的结构

2. 摘要化:
最简单做法就是对格式化以后的数据做sha256计算，这个结果就是一个fingerprint
用这个fingerprint来验证解包后的数据等完整性

那我给你写一个简单直白的第 3 步（加密）说明，你可以直接放进报告里：

3. 加密
	1.	先随机生成一个 AES 临时密钥（CEK）。
	2.	用这个 AES 密钥把格式化后的数据加密，得到密文。
	3.	把这个 AES 密钥分别用 Owner 的公钥 和 User 的公钥 各加密一份，放进 KeyringList。
	4.	这样解包时，Owner 或 User 就能用自己的私钥解开对应的 AES 密钥，再还原数据。

4. 完整性保护（签名）
	1.	把封包里的关键字段（头部、元数据、摘要、加密后的数据）拼接成一个固定的表示形式。
	2.	用 Producer 的私钥 对这些内容做一次数字签名。
	3.	任何人拿到数据胶囊后，都可以用 Producer 的公钥 来验证签名，确认数据在传输和存储过程中没有被篡改。

5. 策略绑定
	1.	在封包的时候，可以附加一些访问策略，比如规定“只有某些角色可以解包”或者“数据在某个时间之后失效”。
	2.	这些策略和数据一起放进胶囊，保证后续使用时有明确的权限约束。
	3.	解包时系统会先检查策略，如果条件不满足，就算有密钥也不能解密数据。

6. 审计记录
	1.	在封包的时候，生成一条“创建胶囊”的事件记录。
	2.	记录的内容包括：时间戳、操作人（Producer）、操作动作（create）、结果（success）。
	3.	这些审计信息可以跟随胶囊一起保存，方便后续追溯是谁、在什么时候创建了这份数据。

### 解包流程
1.	检查结构
确认胶囊的格式是否完整，字段是否符合约定。
2.	验证签名
用 Producer 的公钥验证签名，确认数据没有被篡改。
3.	检查策略
看自己是否符合胶囊里绑定的访问条件（比如角色、时间限制等）。
4.	解密 AES 密钥
从 KeyringList 找到对应自己的那份加密 AES 密钥，用私钥解开，得到临时 AES 密钥（CEK）。
5.	解密数据
用这个 AES 密钥解密数据内容，得到明文。
6.	验证摘要
对明文重新计算一次 SHA-256 摘要，跟胶囊里存的 fingerprint 对比，确认数据完整性。
7.	记录审计
生成一条“读取/解包”的事件记录，方便后续追踪。

---

## 漏洞与解决方案

在前述设计中，AES 密钥（CEK）虽然是加密后存放在数据胶囊中，但只要有权限的组成员能够解开 CEK，就可能将其转交给未授权的第三方。这会破坏分组权限的边界，属于潜在漏洞。

### 解决思路

1. **集中解密模式**  
   - 将各权限组的私钥集中存放在数据银行（Data Bank）等可信中心。  
   - 使用者提交请求后，由数据银行检查策略并代理解密，使用者只收到解密后的必要部分或视图，而不是直接获得 CEK。  
   - 这样可以避免密钥在用户侧扩散。

2. **短期授权与水印**  
   - 授权包（GrantEnvelope）应带有有效期，过期后自动失效。  
   - 在解密输出中嵌入不可见水印或标识，便于追溯泄露来源。

3. **最小化分组**  
   - 建议减少组的粒度，尽量按个人授权或小组授权，降低横向扩散风险。

4. **审计与追责**  
   - 所有授权与解密操作必须记录在审计日志中，确保违规扩散可以被追踪。

通过以上措施，可以在保持数据胶囊固定与通用性的同时，降低密钥扩散带来的风险。  