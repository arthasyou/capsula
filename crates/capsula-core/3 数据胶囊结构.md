# 数据胶囊结构

## 介绍

数据胶囊是一个统一外壳 + 分层内容的安全容器：
外壳负责绑定与可信，内容分为0/1/2 三阶分别承载原始数据、解释与聚合。

三个核心抽象（读者先记住这三个名词）
	•	通用外壳（Capsule）：像“快递盒”。把头部信息、访问控制、密钥环、载荷与完整性签名整体绑定起来。
	•	最小封装块（SealedBlock）：像“密封小包”。一份密文（内联或URL）+ 明文类型 + 作者证明，可以独立解密与验证。
	•	0/1/2 阶胶囊（Cap0/1/2）：像“原件—解读—目录”。按用途分层组织：原始 → 解释 → 聚合。

为什么要分 0/1/2 三阶
	•	0 阶（原始层）：只做“把原始数据安全地密封并可验证”。原件与“文字注释版”各自是一个 SealedBlock（常是 URL 指向 S3）。
	•	1 阶（解释层）：在不暴露 0 阶原件的前提下，传递元数据与摘要（也是 SealedBlock），并指向 Cap0。ZKP（如需）在这里对“文字/结构化片段”给出可验证结论。
	•	2 阶（聚合层）：按所有者聚合多个 1 阶 ID，形成“明文目录”（可签名）。检索快、解密慢（按需拉取 1 阶/0 阶）。

思想要点：把解密和解释从检索中“解耦”。上层先找目录（2 阶），再精确拉取解释（1 阶），最后才需要时解封原件（0 阶）。

安全绑定“三件套”（理解这三点就懂了）
	1.	AAD（额外认证数据）：把 header / policy / keyring / payload 的摘要喂给对称加密（AEAD），壳换了就解不开。
	2.	Integrity（外壳签名）：对“整个胶囊的规范化摘要”做签名，盒子没被动过。
	3.	AuthorProof（作者证明）：对“明文摘要（或 Merkle 根）”签名，内容没被换过，且谁写的可追。

外壳保证“盒子真”；作者证明保证“内容真”；AAD把“盒子”和“内容”强绑定。



边界与不做的事（帮助读者把握范围）
	•	本文不规定具体 PKI/证书体系、KMS 细节、审计系统实现、ZKP 具体电路；
	•	本文只讲清楚：为什么分层、怎么绑定、各层承担什么职责。

### 通用数据胶囊（测试版设计）

通用数据胶囊设计思路

通用数据胶囊的设计目标，是用一个统一的外壳来封装各种类型的数据（原始文件、文字注释、摘要结构等），并且在存储、传输、使用的全过程中保证机密性、完整性和可控访问。
	•	统一外壳：用 Capsule 作为顶层容器，不论是 0、1、2 阶胶囊，都能放在 payload 字段里。这样只需一个外壳定义，就能支持不同场景的数据。
	•	分层设计：头部（Header）负责基本的标识和分类，policy 管控访问策略，keyring 管理对称密钥的安全分发，integrity 保证整体完整性与来源可信。
	•	最小必需信息：每一层都只保存解密、验证、追溯所必需的信息，保持结构精简，便于跨语言、跨系统实现。
	•	安全绑定：通过 aad（额外认证数据）把头部、策略、密钥环和载荷牢固绑定，避免替换或重放攻击。
	•	可扩展性：设计中保留了 payload、watermark 等开放字段，未来可以灵活扩展，不会破坏已有兼容性。

总结来说，通用数据胶囊就是一个 安全、通用、可扩展的数据容器：它既像文件的“外包装”，又像合同的“封条”，确保内容能在不同应用和不同阶段安全传递和使用。

```rust
struct Capsule {
    header: Header,             // 胶囊头（版本、类型、时间戳等）
    aad: String,                // 额外认证数据对称加密使用（Additional Authenticated Data）
    policy: Control,            // 访问控制只存储指针（详细设计请参考访问控制部分）
    keyring: HashMap<KeyWrap>,  // 对称密钥加密后的map list
    payload: Cap0 | Cap1 | Cap2,// 不同数据胶囊的内容（0,1,2阶等数据胶囊具体结构）
    integrity: Integrity,       // 对整个胶囊的签名保证完整性
}

// 胶囊头部还可以添加其它信息用于搜索和分类
struct Header {
    id: String,             // "cid:...base32"
    verion: String,         // "1.0"
    stage: CapsulaStage,    // 1
    type_: String,          // 如 "medical.blood_test"
    created_at: String,     // 2025-9-15
}

 struct Integrity {
    signature: Signature, // 作者签名
    digest:Digest   // 明文指纹
    watermark: Option<Watermark>, // 数字水印
}

 struct Signature {
    alg: String,    // "签名算法"
    sig: String,    // base64签名
    signer: String, // 标识（如机构/证书主体）
}

struct Digest {
    alg: String,  // 例: "SHA-256" / "Merkle-SHA256"
    hash: String, // hex 或 base64
}


```

### 0阶数据胶囊
0阶数据胶囊需要分成3个部分
1 原始数据加密后的密文存储在S3服务器
2 原始数据文字注释加密后的密文存储在S3服务器
3 0阶级数据胶囊元明文标识存储在数据库里

下面例子展示了一个0阶数据胶囊
按照上面0阶级数据胶囊的3个部分
下面的结构就是封装1和2的内容
``` rust

// 0阶数据胶囊：两个加密块通常是不同明文 ⇒ 各自独立 AuthorProof
struct Cap0 {
    origin: SealedBlock,              // 原始数据 → 独立 proof
    origin_text: Option<SealedBlock>, // 文字注释 → 独立 proof
}

```

### 最小化密文模块设计

最小化封装块设计思想

最小化封装块（SealedBlock）的核心目标是：用最小的结构，把一份加密数据与它的完整性和来源证明牢固绑定起来。
	•	Ciphertext 只负责存储解密所必需的信息，并且兼容两种形态：小数据可以直接内联存放密文，大文件则用外链（URL）引用。这样一套结构就能同时覆盖不同场景，保持通用性和简洁性。
	•	AuthorProof 绑定的是明文的摘要（digest），保证即使存储位置或密文表现形式不同，只要明文相同就能得到同样的证明，从而实现可验证的不可抵赖性。
	•	content_type 只是标记明文是什么类型的数据，方便解密后正确解析。

整体设计思想就是：每个 SealedBlock = 密文 + 明文类型 + 作者证明，既最小化，又能独立验证，方便在更大结构（比如 0 阶胶囊）里自由组合。

``` rust

// 通用封装单元：一个加密块 + 内容类型 + 该明文的作者证明（内联或引用）
struct SealedBlock {
    block: Ciphertext,            // 内联密文或外链密文（二选一，见下）
    content_type: ContentType,    // 明文 MIME
    proof: AuthorProof,           // 该“明文指纹”的签名证明
}

// 最小通用密文结构（统一容器）
// 公共域 + 存储变体：inline 或 external（URL）
struct Ciphertext {
    enc: EncAlg,                  // AEAD 算法
    nonce: String,                // base64(12B)
    aad: String,                  // base64(AAD) 建议为签名域摘要
    len: u64,                     // 明文长度
    dek_id: String,               // DEK 索引（外部 KeyWrap）
    digest: Digest,               // 明文指纹（与 AuthorProof.subject 相同）
    storage: CipherStorage,       // —— 存储变体 ——
}

enum CipherStorage {
    Inline {
        ct_b64: String,                   // base64(ciphertext||tag)
        ciphertext_len: Option<u64>,
        ciphertext_digest: Option<Digest> // 传输校验可选
    },
    External {
        uri: String,                      // s3://... 或 https://...
        ciphertext_len: Option<u64>,
        ciphertext_digest: Option<Digest>,
    }
}

// 对“某个明文指纹”的签名证明（
struct AuthorProof {
    digest: Digest,              // 明文指纹（或 Merkle 根）
    schema_hash: Option<String>,  // 可选：结构/规范哈希
    issued_at: Option<String>,    // 可选：时间
    signature: Signature,         // 明文签名签名
}

```

### 1阶数据胶囊

有了最小通用密文模块，那么1阶数据胶囊设计就变得非常简单
只需要封装"元数据"和"摘要"2个部分,再加上一个关联的0阶数据胶囊id
1阶数据胶囊摘要部分还涉及到zkp证明，（这部分暂时忽略，请看zkp证明细节）

``` rust
struct Cap1 {
    cap0_id: String,
    meta: SealedBlock,
    summary: SealedBlock,
    zkp: Option<ZkpProof>, 
}

```

### 2阶数据胶囊

2阶数据胶囊就是把所有属于某个owner的所有胶囊封装到一起
封装到内容目前设计的都是明文，只是关联1阶胶囊的id
再加上一个owner_id最为标识
这里也可以考虑加密owner信息

``` rust

pub struct Cap2 {
    pub owner_id: String,
    pub refs: Vec<RefEntry>,
    pub bundle_hash: Digest,    // 明文指纹
    pub bundle_signature: Signature, // 作者签名
}


pub struct RefEntry {
    pub report_type: String,        // 例如 "血常规报告" / "体检报告"
    pub ids: Vec<String>,           // 对应的一阶胶囊 ID 列表
}

```

## 结构图

```
Capsule（通用外壳）
│
├── Header（胶囊头）
│    ├── id / version / stage / type / created_at
│    └── ...（可扩展的分类、搜索信息）
│
├── aad（额外认证数据，用于 AEAD 上下文绑定）
│
├── Policy（访问控制策略）
│
├── Keyring（密钥环）
│    └── { dek_id => KeyWrap }  // 对称密钥的加密包
│
├── Payload（载荷：可为 Cap0 / Cap1 / Cap2）
│    │
│    ├── Cap0（0阶数据胶囊：原始层）
│    │     ├── origin: SealedBlock      // 原始数据密文 + 作者证明
│    │     └── origin_text: SealedBlock?// 注释版密文 + 作者证明
│    │
│    ├── Cap1（1阶数据胶囊：解释层）
│    │     ├── cap0_id（关联的 0阶ID）
│    │     ├── meta: SealedBlock        // 元数据密文 + 作者证明
│    │     └── summary: SealedBlock     // 摘要密文 + 作者证明
│    │
│    └── Cap2（2阶数据胶囊：聚合层）
│          ├── owner_id（所有者标识）
│          ├── refs: [ RefEntry ]       // 类型 → 多个 1阶ID
│          ├── bundle_hash（refs 哈希）
│          └── bundle_signature（签名）
│
└── Integrity（完整性保证）
     ├── signature（作者签名）
     ├── digest（明文指纹 / Merkle 根）
     └── watermark?（可选水印）
```

## ① 生产流程：原始数据 → 0阶 → 1阶 → 2阶（并装入通用外壳）

```
[数据产生]                              
   │  (原始文件 raw、文字注释 text)
   ▼
[计算明文摘要 Digest(raw/text)]
   │
   ├─►[AuthorProof(raw)]  = 签( Digest(raw), schema?, issued_at? )
   │
   └─►[AuthorProof(text)] = 签( Digest(text), schema?, issued_at? )
   │
   ▼
[生成 DEK 并 AEAD 加密]
   │  （enc/nonce/aad/len 记录在 Ciphertext 公共域）
   │
   ├─►[密文存储方式选择]
   │     ├─ Inline：生成 ct_b64
   │     └─ External：上传 S3 得到 uri，并记录 ciphertext_digest?/len?
   │
   ▼
[构造 SealedBlock]
   │   block = Ciphertext(…)
   │   content_type = 明文 MIME
   │   proof = 对应的 AuthorProof
   │
   ├─► origin: SealedBlock(raw)
   └─► origin_text?: SealedBlock(text)
   │
   ▼
[构造 0阶胶囊 Cap0]
   │   { origin, origin_text? }
   │
   ▼
[构造 1阶胶囊 Cap1]
   │   cap0_id ← 关联 Cap0
   │   meta     = SealedBlock(元数据)
   │   summary  = SealedBlock(摘要/解读)
   │
   ▼
[构造 2阶胶囊 Cap2]
   │   owner_id
   │   refs = [{report_type, ids=[cap1_id…]}…]
   │   bundle_hash = Hash(规范化 refs)
   │   bundle_signature = 签(bundle_hash)
   │
   ▼
[装入通用外壳 Capsule]
   header   = {id/version/stage/type/created_at}
   aad      = 绑定 header/policy/keyring/payload 的摘要
   policy   = 访问控制策略
   keyring  = { dek_id => KeyWrap(接收者公钥包裹 DEK) }
   payload  = Cap0 | Cap1 | Cap2
   integrity= { signature, digest(可为整体或 Merkle 根), watermark? }
```

## ② 消费流程：读取与验证（从外壳到明文）
```
[拿到 Capsule]
   │
   ├─ 校验 integrity.signature 覆盖面（含 header/policy/keyring/payload 摘要）
   ├─ 取出 aad，作为 AEAD 的 AAD 上下文
   └─ 根据 payload 类型进入：

   A) Cap0：
      - 读取 origin / origin_text（SealedBlock）
      - 如 External：下载 uri 并校验 ciphertext_digest?/len?
      - 解包 keyring，用 dek_id 找 KeyWrap → 解出 DEK
      - AEAD 解密( enc, nonce, aad ) → 明文
      - 计算 Digest(明文) == Ciphertext.digest
      - 验证 AuthorProof.signature 覆盖其 digest/schema?/issued_at?

   B) Cap1：
      - 用 cap0_id 关联 Cap0（可选校验跨层一致性）
      - 同 A) 流程分别解密 meta / summary

   C) Cap2：
      - 校验 bundle_signature( bundle_hash )
      - 规范化 refs 重算哈希比对 bundle_hash
      - 逐条取 refs.ids → 定位 Cap1 → 再按 B) 解密
```

